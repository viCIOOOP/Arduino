                             Целочисленное деление
При целочисленном делении результат не округляется по "математическим" правилам, дробная часть просто отсекается, фактически это округление вниз: и 9/10 и 1/10 дадут 0.
При использовании float само собой получится 0.9 и 0.1

Если нужно целочисленное деление с округлением вверх его можно записать так:
(x + y - 1) / y

Для округления по обычным математическим правилам можно использовать функцию round()

                          Переполнение переменной

при переполнении в большую сторону из нового значения вычитается максимальное значение переменной, и у неё остаётся только остаток

// тип данных byte (0.. 255)
byte val = 255;
// тут val станет равным 0
val++;
// а тут из нуля станет 246
val -= 10;
// переполним! Останется 13
val = 525;
// и обратно: val равна 236
val = -20;

                          Особенность больших вычислений

Для сложения и вычитания по умолчанию используется ячейка 4 байта (long), но для умножения и деления - 2 байта (int).
 Если при умножении или делении в текущем действии результат превысит 32768 - ячейка переполнится и мы получим некорректный результат.

Для цифр существуют модификаторы, делающие то же самое:

U или u - перевод в uint16_t (от 0 до 65'535). Пример: 36000u
L или l - перевод в int32_t (-2 147 483 648… 2 147 483 647). Пример: 325646L
UL или ul - перевод в uint32_t (от 0 до 4 294 967 295). Пример: 361341ul

Посмотрим, как это работает на практике:

long val;
val = 2000000000 + 6000000;         // посчитает корректно (т.к. сложение)
val = 25 * 1000;                    // посчитает корректно (умножение, меньше 32'768)
val = 35 * 1000;                    // посчитает НЕКОРРЕКТНО! (умножение, больше 32'768)
val = (long)35 * 1000;              // посчитает корректно (выделяем память (long) )
val = 35 * 1000L;                   // посчитает корректно (модификатор L)
val = 35 * 1000u;                   // посчитает корректно (модификатор u)
val = 70 * 1000u;                   // посчитает НЕКОРРЕКТНО (модификатор u, результат > 65535)
val = 1000 + 35 * 10 * 100;         // посчитает НЕКОРРЕКТНО! (в умножении больше 32'768)
val = 1000 + 35 * 10 * 100L;        // посчитает корректно! (модификатор L)
val = (long)35 * 1000 + 35 * 1000;  // посчитает НЕКОРРЕКТНО! Второе умножение всё портит
val = (long)35 * 1000 + (long)35 * 1000;  // посчитает корректно (выделяем память (long) )
val = 35 * 1000L + 35 * 1000L;      // посчитает корректно (модификатор L)

                                    Особенности float
Если в выражении нет float чисел, то вычисления будут иметь целый результат (дробная часть отсекается)

Для получения правильного результата нужно писать преобразование (float) перед действием.

пример:
  
float val;              // далее будем присваивать 100/3, ожидаем результат 33.3333
val = 100 / 3;          // посчитает НЕПРАВИЛЬНО (результат 33.0)
int val1 = 100;         // целочисленная переменная
val = val1 / 3;         // посчитает НЕПРАВИЛЬНО (результат 33.0)
float val2 = 100;       // float переменная
val = val2 / 3;         // посчитает правильно (есть переменная float)
val = (float)100 / 3;   // посчитает правильно (указываем (float) )
val = 100.0 / 3;        // посчитает правильно (есть число float)
val = 100 / 3.0f;       // посчитает правильно (есть число float и модификатор)
















































